Migrate to libssl 1.1
--- a/Src/crypto.c
+++ b/Src/crypto.c
@@ -82,6 +82,7 @@
   int len, plen;
   byte *ptr;
   int err = 0;
+  BIGNUM *key_n, *key_e, *key_d, *key_p, *key_q, *key_dmp1, *key_dmq1, *key_iqmp;
 
   md = buf_new();
   bits = buf->data[0] + 256 * buf->data[1];
@@ -94,32 +95,36 @@
 
   ptr = buf->data + 2;
 
-  key->n = BN_bin2bn(ptr, len, NULL);
+  key_n = BN_bin2bn(ptr, len, NULL);
   buf_append(md, ptr, len);
   ptr += len;
 
-  key->e = BN_bin2bn(ptr, len, NULL);
+  key_e = BN_bin2bn(ptr, len, NULL);
   buf_append(md, ptr, len);
   ptr += len;
 
-  key->d = BN_bin2bn(ptr, len, NULL);
+  key_d = BN_bin2bn(ptr, len, NULL);
   ptr += len;
 
-  key->p = BN_bin2bn(ptr, plen, NULL);
+  key_p = BN_bin2bn(ptr, plen, NULL);
   ptr += plen;
 
-  key->q = BN_bin2bn(ptr, plen, NULL);
+  key_q = BN_bin2bn(ptr, plen, NULL);
   ptr += plen;
 
-  key->dmp1 = BN_bin2bn(ptr, plen, NULL);
+  key_dmp1 = BN_bin2bn(ptr, plen, NULL);
   ptr += plen;
 
-  key->dmq1 = BN_bin2bn(ptr, plen, NULL);
+  key_dmq1 = BN_bin2bn(ptr, plen, NULL);
   ptr += plen;
 
-  key->iqmp = BN_bin2bn(ptr, plen, NULL);
+  key_iqmp = BN_bin2bn(ptr, plen, NULL);
   ptr += plen;
 
+  RSA_set0_key(key, key_n, key_e, key_d);
+  RSA_set0_factors(key, key_p, key_q);
+  RSA_set0_crt_params(key, key_dmp1, key_dmq1, key_iqmp);
+
   digest_md5(md, md);
   if (id)
     err = (memcmp(id, md->data, 16) == 0) ? 0 : -1;
@@ -134,6 +139,7 @@
   int len;
   byte *ptr;
   int err = 0;
+  BIGNUM *key_n, *key_e;
 
   md = buf_new();
   bits = buf->data[0] + 256 * buf->data[1];
@@ -144,13 +150,14 @@
 
   ptr = buf->data + 2;
 
-  key->n = BN_bin2bn(ptr, len, NULL);
+  key_n = BN_bin2bn(ptr, len, NULL);
   buf_append(md, ptr, len);
   ptr += len;
 
-  key->e = BN_bin2bn(ptr, len, NULL);
+  key_e = BN_bin2bn(ptr, len, NULL);
   buf_append(md, ptr, len);
   ptr += len;
+  RSA_set0_key(key, key_n, key_e, NULL);
 
   digest_md5(md, md);
   if (id)
@@ -164,17 +171,22 @@
   byte l[128];
   int n;
   BUFFER *b, *temp;
+  const BIGNUM *key_n, *key_e, *key_d, *key_p, *key_q, *key_dmp1, *key_dmq1, *key_iqmp;
+
+  RSA_get0_key(key, &key_n, &key_e, &key_d);
+  RSA_get0_factors(key, &key_p, &key_q);
+  RSA_get0_crt_params(key, &key_dmp1, &key_dmq1, &key_iqmp);
 
   b = buf_new();
   temp = buf_new();
 
-  n = BN_bn2bin(key->n, l);
+  n = BN_bn2bin(key_n, l);
   assert(n <= 128);
   if (n < 128)
     buf_appendzero(b, 128 - n);
   buf_append(b, l, n);
 
-  n = BN_bn2bin(key->e, l);
+  n = BN_bn2bin(key_e, l);
   assert(n <= 128);
   if (n < 128)
     buf_appendzero(b, 128 - n);
@@ -187,37 +199,37 @@
   buf_appendc(sk, 4);
   buf_cat(sk, b);
 
-  n = BN_bn2bin(key->d, l);
+  n = BN_bn2bin(key_d, l);
   assert(n <= 128);
   if (n < 128)
     buf_appendzero(sk, 128 - n);
   buf_append(sk, l, n);
 
-  n = BN_bn2bin(key->p, l);
+  n = BN_bn2bin(key_p, l);
   assert(n <= 64);
   if (n < 64)
     buf_appendzero(sk, 64 - n);
   buf_append(sk, l, n);
 
-  n = BN_bn2bin(key->q, l);
+  n = BN_bn2bin(key_q, l);
   assert(n <= 64);
   if (n < 64)
     buf_appendzero(sk, 64 - n);
   buf_append(sk, l, n);
 
-  n = BN_bn2bin(key->dmp1, l);
+  n = BN_bn2bin(key_dmp1, l);
   assert(n <= 64);
   if (n < 64)
     buf_appendzero(sk, 64 - n);
   buf_append(sk, l, n);
 
-  n = BN_bn2bin(key->dmq1, l);
+  n = BN_bn2bin(key_dmq1, l);
   assert(n <= 64);
   if (n < 64)
     buf_appendzero(sk, 64 - n);
   buf_append(sk, l, n);
 
-  n = BN_bn2bin(key->iqmp, l);
+  n = BN_bn2bin(key_iqmp, l);
   assert(n <= 64);
   if (n < 64)
     buf_appendzero(sk, 64 - n);
@@ -234,15 +246,17 @@
 {
   byte l[128];
   int n;
+  const BIGNUM *key_n, *key_e, *key_d;
 
   buf_appendc(pk, 0);
   buf_appendc(pk, 4);
-  n = BN_bn2bin(key->n, l);
+  RSA_get0_key(key, &key_n, &key_e, &key_d);
+  n = BN_bn2bin(key_n, l);
   assert(n <= 128);
   if (n < 128)
     buf_appendzero(pk, 128 - n);
   buf_append(pk, l, n);
-  n = BN_bn2bin(key->e, l);
+  n = BN_bn2bin(key_e, l);
   assert(n <= 128);
   if (n < 128)
     buf_appendzero(pk, 128 - n);
@@ -383,23 +397,23 @@
 }
 int buf_crypt(BUFFER *buf, BUFFER *key, BUFFER *iv, int enc)
 {
-  des_key_schedule ks1;
-  des_key_schedule ks2;
-  des_key_schedule ks3;
-  des_cblock i;
+  DES_key_schedule ks1;
+  DES_key_schedule ks2;
+  DES_key_schedule ks3;
+  DES_cblock i;
 
   assert(enc == ENCRYPT || enc == DECRYPT);
   assert((key->length == 16 || key->length == 24) && iv->length == 8);
   assert(buf->length % 8 == 0);
 
   memcpy(i, iv->data, 8);	/* leave iv buffer unchanged */
-  des_set_key((const_des_cblock *) key->data, ks1);
-  des_set_key((const_des_cblock *) (key->data + 8), ks2);
+  DES_set_key((const_DES_cblock *) key->data, &ks1);
+  DES_set_key((const_DES_cblock *) (key->data + 8), &ks2);
   if (key->length == 16)
-    des_set_key((const_des_cblock *) key->data, ks3);
+    DES_set_key((const_DES_cblock *) key->data, &ks3);
   else
-    des_set_key((const_des_cblock *) (key->data + 16), ks3);
-  des_ede3_cbc_encrypt(buf->data, buf->data, buf->length, ks1, ks2, ks3,
+    DES_set_key((const_DES_cblock *) (key->data + 16), &ks3);
+  DES_ede3_cbc_encrypt(buf->data, buf->data, buf->length, &ks1, &ks2, &ks3,
 		       &i, enc);
   return (0);
 }
@@ -407,18 +421,18 @@
 int buf_3descrypt(BUFFER *buf, BUFFER *key, BUFFER *iv, int enc)
 {
   int n = 0;
-  des_key_schedule ks1;
-  des_key_schedule ks2;
-  des_key_schedule ks3;
+  DES_key_schedule ks1;
+  DES_key_schedule ks2;
+  DES_key_schedule ks3;
 
   assert(enc == ENCRYPT || enc == DECRYPT);
   assert(key->length == 24 && iv->length == 8);
 
-  des_set_key((const_des_cblock *) key->data, ks1);
-  des_set_key((const_des_cblock *) (key->data + 8), ks2);
-  des_set_key((const_des_cblock *) (key->data + 16), ks3);
-  des_ede3_cfb64_encrypt(buf->data, buf->data, buf->length, ks1, ks2, ks3,
-			(des_cblock *) iv->data, &n, enc);
+  DES_set_key((const_DES_cblock *) key->data, &ks1);
+  DES_set_key((const_DES_cblock *) (key->data + 8), &ks2);
+  DES_set_key((const_DES_cblock *) (key->data + 16), &ks3);
+  DES_ede3_cfb64_encrypt(buf->data, buf->data, buf->length, &ks1, &ks2, &ks3,
+			(DES_cblock *) iv->data, &n, enc);
   return (0);
 }
 
--- a/Src/pgpcreat.c
+++ b/Src/pgpcreat.c
@@ -158,11 +158,11 @@
 
 static int pgp_3desencrypt(BUFFER *in, BUFFER *out, BUFFER *key, int mdc)
 {
-  des_cblock iv;
+  DES_cblock iv;
   int i, n = 0;
-  des_key_schedule ks1;
-  des_key_schedule ks2;
-  des_key_schedule ks3;
+  DES_key_schedule ks1;
+  DES_key_schedule ks2;
+  DES_key_schedule ks3;
   SHA_CTX c;
 
   assert(key->length == 25);
@@ -170,9 +170,9 @@
   for (i = 0; i < 8; i++)
     iv[i] = 0;
 
-  des_set_key((const_des_cblock *) (key->data + 1), ks1);
-  des_set_key((const_des_cblock *) (key->data + 9), ks2);
-  des_set_key((const_des_cblock *) (key->data+ 17), ks3);
+  DES_set_key((const_DES_cblock *) (key->data + 1), &ks1);
+  DES_set_key((const_DES_cblock *) (key->data + 9), &ks2);
+  DES_set_key((const_DES_cblock *) (key->data+ 17), &ks3);
 
   if (mdc) {
     mdc = 1;
@@ -186,22 +186,23 @@
     SHA1_Update(&c, in->data, in->length);
   }
   n = 0;
-  des_ede3_cfb64_encrypt(out->data + mdc, out->data + mdc, 10, ks1, ks2, ks3, &iv, &n,
-			 ENCRYPT);
+  DES_ede3_cfb64_encrypt(out->data + mdc, out->data + mdc, 10,
+			 &ks1, &ks2, &ks3, &iv, &n, ENCRYPT);
   if (!mdc) {
     iv[6] = iv[0], iv[7] = iv[1];
     memcpy(iv, out->data + 2, 6);
     n = 0;
   }
-  des_ede3_cfb64_encrypt(in->data, out->data + 10 + mdc, in->length, ks1, ks2, ks3,
-			 &iv, &n, ENCRYPT);
+  DES_ede3_cfb64_encrypt(in->data, out->data + 10 + mdc, in->length,
+			 &ks1, &ks2, &ks3, &iv, &n, ENCRYPT);
   if (mdc) {
     SHA1_Update(&c, "\xD3\x14", 2); /* 0xD3 = 0xC0 | PGP_MDC */
-    des_ede3_cfb64_encrypt("\xD3\x14", out->data + 11 + in->length, 2, ks1, ks2, ks3,
-		       &iv, &n, ENCRYPT);
+    DES_ede3_cfb64_encrypt("\xD3\x14", out->data + 11 + in->length, 2,
+			   &ks1, &ks2, &ks3, &iv, &n, ENCRYPT);
     SHA1_Final(out->data + 13 + in->length, &c);
-    des_ede3_cfb64_encrypt(out->data + 13 + in->length, out->data + 13 + in->length, 20, ks1, ks2, ks3,
-		       &iv, &n, ENCRYPT);
+    DES_ede3_cfb64_encrypt(out->data + 13 + in->length,
+			   out->data + 13 + in->length, 20, &ks1, &ks2, &ks3,
+			   &iv, &n, ENCRYPT);
   }
   return (0);
 }
--- a/Src/pgpdata.c
+++ b/Src/pgpdata.c
@@ -131,6 +131,7 @@
   BUFFER *mpi, *out;
   int err = -1;
   RSA *key;
+  BIGNUM *key_n, *key_e, *key_d, *key_q, *key_p, *key_iqmp, *key_dmp1, *key_dmq1;
 
   assert(mode == PK_ENCRYPT || mode == PK_VERIFY || mode == PK_DECRYPT
 	 || mode == PK_SIGN);
@@ -139,28 +140,31 @@
   mpi = buf_new();
 
   mpi_get(k, mpi);
-  key->n = BN_bin2bn(mpi->data, mpi->length, NULL);
+  key_n = BN_bin2bn(mpi->data, mpi->length, NULL);
 
   if (mpi_get(k, mpi) < 0)
     goto end;
-  key->e = BN_bin2bn(mpi->data, mpi->length, NULL);
+  key_e = BN_bin2bn(mpi->data, mpi->length, NULL);
 
+  RSA_set0_key(key, key_n, key_e, NULL);
   if (mode == PK_DECRYPT || mode == PK_SIGN) {
     if (mpi_get(k, mpi) < 0)
       goto end;
-    key->d = BN_bin2bn(mpi->data, mpi->length, NULL);
-
+    key_d = BN_bin2bn(mpi->data, mpi->length, NULL);
+    RSA_set0_key(key, key_n, key_e, key_d);
 #if 1
     /* compute auxiluary parameters */
     mpi_get(k, mpi);		/* PGP'p is SSLeay's q */
-    key->q = BN_bin2bn(mpi->data, mpi->length, NULL);
+    key_q = BN_bin2bn(mpi->data, mpi->length, NULL);
 
     mpi_get(k, mpi);
-    key->p = BN_bin2bn(mpi->data, mpi->length, NULL);
+    key_p = BN_bin2bn(mpi->data, mpi->length, NULL);
+
+    RSA_set0_factors(key, key_p, key_q);
 
     if (mpi_get(k, mpi) < 0)
       goto end;
-    key->iqmp = BN_bin2bn(mpi->data, mpi->length, NULL);
+    key_iqmp = BN_bin2bn(mpi->data, mpi->length, NULL);
 
     {
       BIGNUM *i;
@@ -168,14 +172,16 @@
 
       ctx = BN_CTX_new();
       i = BN_new();
-      key->dmp1 = BN_new();
-      key->dmq1 = BN_new();
+      key_dmp1 = BN_new();
+      key_dmq1 = BN_new();
+
+      BN_sub(i, key_p, BN_value_one());
+      BN_mod(key_dmp1, key_d, i, ctx);
 
-      BN_sub(i, key->p, BN_value_one());
-      BN_mod(key->dmp1, key->d, i, ctx);
+      BN_sub(i, key_q, BN_value_one());
+      BN_mod(key_dmq1, key_d, i, ctx);
 
-      BN_sub(i, key->q, BN_value_one());
-      BN_mod(key->dmq1, key->d, i, ctx);
+      RSA_set0_crt_params(key, key_dmp1, key_dmq1, key_iqmp);
 
       BN_free(i);
     }
@@ -1037,6 +1043,7 @@
   long now;
   int skalgo = 0;
   int err = 0;
+  const BIGNUM *key_n, *key_e, *key_d, *key_p, *key_q, *key_dmp1, *key_dmq1, *key_iqmp;
 
   pkey = buf_new();
   skey = buf_new();
@@ -1061,8 +1068,10 @@
   buf_appendi(skey, 0);
   /* buf_appendi(skey, KEYLIFETIME/(24*60*60)); */
   buf_appendc(skey, PGP_ES_RSA);
-  mpi_bnput(skey, k->n);
-  mpi_bnput(skey, k->e);
+
+  RSA_get0_key(k, &key_n, &key_e, &key_d);
+  mpi_bnput(skey, key_n);
+  mpi_bnput(skey, key_e);
 
 #ifdef USE_IDEA
   if (pass != NULL && pass->length > 0 && remail != 2) {
@@ -1076,16 +1085,18 @@
 #endif /* USE_IDEA */
     buf_appendc(skey, 0);
 
-  mpi_bnputenc(skey, k->d, skalgo, dk, iv);
-  mpi_bnputenc(skey, k->q, skalgo, dk, iv);
-  mpi_bnputenc(skey, k->p, skalgo, dk, iv);
-  mpi_bnputenc(skey, k->iqmp, skalgo, dk, iv);
+  RSA_get0_factors(k, &key_p, &key_q);
+  RSA_get0_crt_params(k, &key_dmp1, &key_dmq1, &key_iqmp);
+  mpi_bnputenc(skey, key_d, skalgo, dk, iv);
+  mpi_bnputenc(skey, key_q, skalgo, dk, iv);
+  mpi_bnputenc(skey, key_p, skalgo, dk, iv);
+  mpi_bnputenc(skey, key_iqmp, skalgo, dk, iv);
 
   buf_clear(p);
-  mpi_bnput(p, k->d);
-  mpi_bnput(p, k->q);
-  mpi_bnput(p, k->p);
-  mpi_bnput(p, k->iqmp);
+  mpi_bnput(p, key_d);
+  mpi_bnput(p, key_q);
+  mpi_bnput(p, key_p);
+  mpi_bnput(p, key_iqmp);
   buf_appendi(skey, pgp_csum(p, 0));
 
   pgp_packet(skey, PGP_SECKEY);
@@ -1133,6 +1144,7 @@
 static void *params(int dsa, int bits)
 {
   DSA *k = NULL;
+  BIGNUM *key_p, *key_q, *key_g;
   DH *d = NULL;
   FILE *f;
   BUFFER *p, *n;
@@ -1166,22 +1178,24 @@
 		k = DSA_new();
 		l = buf_geti(p);
 		buf_get(p, n, l);
-		k->p = BN_bin2bn(n->data, n->length, NULL);
+		key_p = BN_bin2bn(n->data, n->length, NULL);
 		l = buf_geti(p);
 		buf_get(p, n, l);
-		k->q = BN_bin2bn(n->data, n->length, NULL);
+		key_q = BN_bin2bn(n->data, n->length, NULL);
 		l = buf_geti(p);
 		buf_get(p, n, l);
-		k->g = BN_bin2bn(n->data, n->length, NULL);
+		key_g = BN_bin2bn(n->data, n->length, NULL);
 	      } else {
 		d = DH_new();
 		l = buf_geti(p);
 		buf_get(p, n, l);
-		d->p = BN_bin2bn(n->data, n->length, NULL);
+		key_p = BN_bin2bn(n->data, n->length, NULL);
 		l = buf_geti(p);
 		buf_get(p, n, l);
-		d->g = BN_bin2bn(n->data, n->length, NULL);
+		key_g = BN_bin2bn(n->data, n->length, NULL);
+		key_q = NULL;
 	      }
+	      DSA_set0_pqg(k, key_p, key_q, key_g);
 	      break;
 	    }
 	    buf_appends(p, line);
@@ -1200,13 +1214,14 @@
       errlog(NOTICE, "Generating DSA parameters.\n");
       k = DSA_generate_parameters(bits, NULL, 0, NULL, NULL, NULL, NULL);
       p = buf_new();
-      l = BN_bn2bin(k->p, b);
+      DSA_get0_pqg(k, &key_p, &key_q, &key_g);
+      l = BN_bn2bin(key_p, b);
       buf_appendi(p, l);
       buf_append(p, b, l);
-      l = BN_bn2bin(k->q, b);
+      l = BN_bn2bin(key_q, b);
       buf_appendi(p, l);
       buf_append(p, b, l);
-      l = BN_bn2bin(k->g, b);
+      l = BN_bn2bin(key_g, b);
       buf_appendi(p, l);
       buf_append(p, b, l);
       encode(p, 64);
@@ -1225,11 +1240,12 @@
     if (d == NULL) {
       errlog(NOTICE, "Generating DH parameters. (This may take a long time!)\n");
       d = DH_generate_parameters(bits, DH_GENERATOR_5, NULL, NULL);
+      DSA_get0_pqg(d, &key_p, &key_q, &key_g);
       p = buf_new();
-      l = BN_bn2bin(d->p, b);
+      l = BN_bn2bin(key_p, b);
       buf_appendi(p, l);
       buf_append(p, b, l);
-      l = BN_bn2bin(d->g, b);
+      l = BN_bn2bin(key_g, b);
       buf_appendi(p, l);
       buf_append(p, b, l);
       encode(p, 64);
@@ -1258,6 +1274,7 @@
   BUFFER *dk, *sig, *iv, *p;
   long now;
   int err = 0;
+  const BIGNUM *key_p, *key_q, *key_g, *pub_key, *priv_key;
 
   pkey = buf_new();
   skey = buf_new();
@@ -1289,12 +1306,13 @@
   buf_setc(skey, 4);
   buf_appendl(skey, now);
   buf_appendc(skey, PGP_S_DSA);
-  mpi_bnput(skey, s->p);
-  mpi_bnput(skey, s->q);
-  mpi_bnput(skey, s->g);
-  mpi_bnput(skey, s->pub_key);
-
-  mpi_bnput(secret, s->priv_key);
+  DSA_get0_pqg(s, &key_p, &key_q, &key_g);
+  mpi_bnput(skey, key_p);
+  mpi_bnput(skey, key_q);
+  mpi_bnput(skey, key_g);
+  DSA_get0_key(s, &pub_key, &priv_key);
+  mpi_bnput(skey, pub_key);
+  mpi_bnput(secret, priv_key);
   buf_appendi(secret, pgp_csum(secret, 0));
   makeski(secret, pass, remail);
   buf_cat(skey, secret);
@@ -1304,12 +1322,16 @@
   buf_setc(subkey, 4);
   buf_appendl(subkey, now);
   buf_appendc(subkey, PGP_E_ELG);
-  mpi_bnput(subkey, e->p);
-  mpi_bnput(subkey, e->g);
-  mpi_bnput(subkey, e->pub_key);
+
+  DH_get0_pqg(e, &key_p, &key_q, &key_g);
+  mpi_bnput(skey, key_p);
+  mpi_bnput(subkey, key_p);
+  mpi_bnput(subkey, key_g);
+  DH_get0_key(s, &pub_key, &priv_key);
+  mpi_bnput(subkey, pub_key);
 
   buf_clear(secret);
-  mpi_bnput(secret, e->priv_key);
+  mpi_bnput(secret, priv_key);
   buf_appendi(secret, pgp_csum(secret, 0));
   makeski(secret, pass, remail);
   buf_cat(subkey, secret);
@@ -1360,29 +1382,33 @@
   BUFFER *mpi, *b;
   DSA *d;
   DSA_SIG *sig = NULL;
+  BIGNUM *key_p, *key_q, *key_g, *pub_key, *priv_key, *sig_s, *sig_r;
 
   d = DSA_new();
   b = buf_new();
   mpi = buf_new();
   mpi_get(key, mpi);
-  d->p = BN_bin2bn(mpi->data, mpi->length, NULL);
+  key_p = BN_bin2bn(mpi->data, mpi->length, NULL);
   mpi_get(key, mpi);
-  d->q = BN_bin2bn(mpi->data, mpi->length, NULL);
+  key_q = BN_bin2bn(mpi->data, mpi->length, NULL);
   mpi_get(key, mpi);
-  d->g = BN_bin2bn(mpi->data, mpi->length, NULL);
+  key_g = BN_bin2bn(mpi->data, mpi->length, NULL);
+  DSA_set0_pqg(d, key_p, key_q, key_g);
   mpi_get(key, mpi);
-  d->pub_key = BN_bin2bn(mpi->data, mpi->length, NULL);
+  pub_key = BN_bin2bn(mpi->data, mpi->length, NULL);
   if (mpi_get(key, mpi) == -1) {
     goto end;
   }
-  d->priv_key = BN_bin2bn(mpi->data, mpi->length, NULL);
+  priv_key = BN_bin2bn(mpi->data, mpi->length, NULL);
+  DSA_set0_key(d, pub_key, priv_key);
 
   sig = DSA_do_sign(data->data, data->length, d);
   if (sig) {
-    buf_prepare(b, BN_num_bytes(sig->r));
-    b->length = BN_bn2bin(sig->r, b->data);
+    DSA_SIG_get0(sig, &sig_r, &sig_s);
+    buf_prepare(b, BN_num_bytes(sig_r));
+    b->length = BN_bn2bin(sig_r, b->data);
     mpi_put(out, b);
-    b->length = BN_bn2bin(sig->s, b->data);
+    b->length = BN_bn2bin(sig_s, b->data);
     mpi_put(out, b);
   }
  end:
--- a/Src/pgpget.c
+++ b/Src/pgpget.c
@@ -400,12 +400,12 @@
 static int pgp_3desdecrypt(BUFFER *in, BUFFER *out, BUFFER *key, int mdc)
 {
   int err = 0;
-  des_cblock iv;
+  DES_cblock iv;
   byte hdr[10];
   int i, n;
-  des_key_schedule ks1;
-  des_key_schedule ks2;
-  des_key_schedule ks3;
+  DES_key_schedule ks1;
+  DES_key_schedule ks2;
+  DES_key_schedule ks3;
   SHA_CTX c;
   char md[20]; /* we could make hdr 20 bytes long and reuse it for md */
 
@@ -423,12 +423,13 @@
   for (i = 0; i < 8; i++)
     iv[i] = 0;
 
-  des_set_key((const_des_cblock *) key->data, ks1);
-  des_set_key((const_des_cblock *) (key->data + 8), ks2);
-  des_set_key((const_des_cblock *) (key->data+ 16), ks3);
+  DES_set_key((const_DES_cblock *) key->data, &ks1);
+  DES_set_key((const_DES_cblock *) (key->data + 8), &ks2);
+  DES_set_key((const_DES_cblock *) (key->data+ 16), &ks3);
 
   n = 0;
-  des_ede3_cfb64_encrypt(in->data + mdc, hdr, 10, ks1, ks2, ks3, &iv, &n, DECRYPT);
+  DES_ede3_cfb64_encrypt(in->data + mdc, hdr, 10, &ks1, &ks2, &ks3,
+			 &iv, &n, DECRYPT);
   if (n != 2 || hdr[8] != hdr[6] || hdr[9] != hdr[7]) {
     err = -1;
     goto end;
@@ -441,8 +442,8 @@
     memcpy(iv, in->data + 2, 6);
     n = 0;
   }
-  des_ede3_cfb64_encrypt(in->data + 10 + mdc, out->data, in->length - 10 + mdc, ks1,
-			 ks2, ks3, &iv, &n, DECRYPT);
+  DES_ede3_cfb64_encrypt(in->data + 10 + mdc, out->data, in->length - 10 + mdc,
+			 &ks1, &ks2, &ks3, &iv, &n, DECRYPT);
   if (mdc) {
     if (out->length > 22) {
       out->length -= 22;
